name: Deploy financeiro-ratc

on:
  push:
    branches: [main]
    paths-ignore:
      - 'README.md'
      - 'docs/**'
      - '.github/**'
  workflow_dispatch:

permissions:
  contents: read

concurrency:
  group: deploy-financeiro-ratc-${{ github.ref }}
  cancel-in-progress: true

defaults:
  run:
    shell: bash

jobs:
  deploy:
    name: Build & Deploy (production)
    runs-on: ubuntu-latest
    timeout-minutes: 35
    environment:
      name: production
      url: https://financeiro.ratc.com.br

    env:
      # Quantidade de releases a manter
      KEEP_RELEASES: '3'

      # Configurações do app/infra
      APP_NAME: financeiro-ratc
      APP_DIR: /opt/financeiro-ratc
      DOMAIN: financeiro.ratc.com.br

      # Node/Next/Prisma
      NODE_VERSION: '22'
      NEXT_TELEMETRY_DISABLED: '1'
      PRISMA_CLI_QUERY_ENGINE_TYPE: 'library'
      CI: 'true'

    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          persist-credentials: false

      - name: Compute release id
        run: |
          set -euo pipefail
          SHORT_SHA="${GITHUB_SHA::7}"
          TS="$(date +%Y%m%d%H%M%S)"
          echo "RELEASE_ID=${SHORT_SHA}-${TS}" >> "$GITHUB_ENV"

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'
          cache-dependency-path: 'package-lock.json'

      - name: Cache Next.js & Prisma
        uses: actions/cache@v4
        with:
          path: |
            ~/.cache/prisma
            .next/cache
          key: next-prisma-${{ runner.os }}-node${{ env.NODE_VERSION }}-${{ hashFiles('package-lock.json', 'prisma/schema.prisma') }}
          restore-keys: |
            next-prisma-${{ runner.os }}-node${{ env.NODE_VERSION }}-

      - name: Install dependencies
        run: npm ci --prefer-offline --no-audit --fund=false

      - name: Write build-time .env (masked)
        if: ${{ secrets.ENV != '' }}
        run: |
          set -euo pipefail
          umask 077
          printf "%s" "${{ secrets.ENV }}" > .env
          echo "Build-time .env created"

      - name: Prisma generate (CI)
        run: npx prisma generate

      - name: Build (Next.js standalone if enabled)
        env:
          NODE_OPTIONS: '--max-old-space-size=4096'
          SKIP_BUILD_CHECKS: 'true'
          # Dummy DATABASE_URL para os tipos do Prisma no build
          DATABASE_URL: 'mysql://user:pass@localhost:3306/db'
        run: |
          set -euo pipefail
          npm run build
          if [ -d ".next/standalone" ]; then
            echo "Standalone build ✅"
          else
            echo "Standalone build não encontrado; será usado build regular ⚠"
          fi

      - name: Create deployment bundle
        run: |
          set -euo pipefail
          DEPLOY_DIR="deploy-bundle"
          rm -rf "$DEPLOY_DIR"
          mkdir -p "$DEPLOY_DIR"

          # Sempre inclua package.json e lock (úteis para build regular)
          cp package.json package-lock.json "$DEPLOY_DIR/"

          if [ -d ".next/standalone" ]; then
            cp -r .next/standalone/* "$DEPLOY_DIR/"
            mkdir -p "$DEPLOY_DIR/.next"
            cp -r .next/static "$DEPLOY_DIR/.next/static"
            [ -d public ] && cp -r public "$DEPLOY_DIR/" || true
            cp -r prisma "$DEPLOY_DIR/"
          else
            cp -r .next "$DEPLOY_DIR/"
            [ -d public ] && cp -r public "$DEPLOY_DIR/" || true
            cp -r prisma "$DEPLOY_DIR/"
            for d in app src lib components hooks; do [ -d "$d" ] && cp -r "$d" "$DEPLOY_DIR/" || true; done
            for f in next.config.* tsconfig.json middleware.ts; do [ -f "$f" ] && cp "$f" "$DEPLOY_DIR/" || true; done
          fi

          tar -czf "deploy-${RELEASE_ID}.tar.gz" -C "$DEPLOY_DIR" .
          echo "Bundle criado: deploy-${RELEASE_ID}.tar.gz"

      - name: Cleanup local .env
        if: always()
        run: rm -f .env || true

      - name: Upload bundle (debug opcional)
        uses: actions/upload-artifact@v4
        with:
          name: deploy-${{ env.RELEASE_ID }}
          path: deploy-${{ env.RELEASE_ID }}.tar.gz
          retention-days: 3

      - name: Ensure server base dirs
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ secrets.VPS_HOST }}
          username: ${{ secrets.VPS_USER }}
          key: ${{ secrets.VPS_SSH_KEY }}
          port: ${{ secrets.VPS_PORT || 22 }}
          script_stop: true
          script: |
            set -euo pipefail
            APP_DIR="${{ env.APP_DIR }}"
            mkdir -p "${APP_DIR}/releases" "${APP_DIR}/shared" "${APP_DIR}/uploads"
            [ -f "${APP_DIR}/shared/.env" ] || touch "${APP_DIR}/shared/.env"

      - name: Push bundle to server (rsync)
        uses: burnett01/rsync-deployments@7.0.1
        with:
          switches: -avz
          path: deploy-${{ env.RELEASE_ID }}.tar.gz
          remote_path: ${{ env.APP_DIR }}/uploads/
          remote_host: ${{ secrets.VPS_HOST }}
          remote_user: ${{ secrets.VPS_USER }}
          remote_key: ${{ secrets.VPS_SSH_KEY }}
          remote_port: ${{ secrets.VPS_PORT || 22 }}

      - name: Deploy & reload (atomic with health-check)
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ secrets.VPS_HOST }}
          username: ${{ secrets.VPS_USER }}
          key: ${{ secrets.VPS_SSH_KEY }}
          port: ${{ secrets.VPS_PORT || 22 }}
          script_stop: true
          script: |
            set -euo pipefail

            APP_NAME="${{ env.APP_NAME }}"
            APP_DIR="${{ env.APP_DIR }}"
            RELEASE_ID="${{ env.RELEASE_ID }}"
            RELEASES="${APP_DIR}/releases"
            UPLOADS="${APP_DIR}/uploads"
            SHARED="${APP_DIR}/shared"
            CURRENT="${APP_DIR}/current"
            NEW_RELEASE="${RELEASES}/${RELEASE_ID}"

            # Extrai novo release
            mkdir -p "${NEW_RELEASE}"
            tar -xzf "${UPLOADS}/deploy-${RELEASE_ID}.tar.gz" -C "${NEW_RELEASE}"

            # Linka .env compartilhado
            ln -sfn "${SHARED}/.env" "${NEW_RELEASE}/.env"

            # Guarda release anterior (para rollback)
            PREV_RELEASE="$(readlink -f "${CURRENT}" 2>/dev/null || true)"

            cd "${NEW_RELEASE}"

            # Instala dependências apenas para build regular
            if [ ! -f "server.js" ]; then
              echo "Build regular detectado — instalando dependências de runtime…"
              export NPM_CONFIG_CACHE="${SHARED}/.npm"
              npm ci --omit=dev --no-audit --fund=false
            else
              echo "Standalone detectado — pulando npm install."
            fi

            # Migrations & client Prisma com npx efêmero
            export NODE_ENV=production
            export NEXT_TELEMETRY_DISABLED=1
            export PRISMA_CLI_QUERY_ENGINE_TYPE=library

            echo "Executando prisma migrate deploy…"
            npx --yes prisma migrate deploy

            echo "Gerando prisma client…"
            npx --yes prisma generate

            # Aponta 'current' para o novo release
            ln -sfn "${NEW_RELEASE}" "${CURRENT}"

            # Start/reload com PM2 a partir de 'current'
            cd "${CURRENT}"

            # Carrega variáveis do .env para o ambiente do shell (PM2/Next em runtime)
            if [ -f ".env" ]; then
              # Desabilita 'set -u' temporariamente para evitar erro com variáveis não definidas
              set +u
              set -a
              . ./.env
              set +a
              set -u
            fi

            PORT="${PORT:-3000}"

            if pm2 describe "${APP_NAME}" >/dev/null 2>&1; then
              echo "Reload PM2 ${APP_NAME}…"
              pm2 reload "${APP_NAME}" --update-env || pm2 restart "${APP_NAME}" --update-env
            else
              echo "Start PM2 ${APP_NAME}…"
              if [ -f "server.js" ]; then
                pm2 start "node server.js" --name "${APP_NAME}" --time
              elif [ -f "package.json" ] && grep -q '"start"' package.json; then
                pm2 start "npm start" --name "${APP_NAME}" --time
              else
                pm2 start "node node_modules/.bin/next start" --name "${APP_NAME}" --time
              fi
            fi

            pm2 save || true

            # Health-check simples (localhost)
            echo "Health check http://127.0.0.1:${PORT}/"
            ok=0
            for i in 1 2 3 4 5; do
              if curl -fsS --max-time 5 "http://127.0.0.1:${PORT}/" >/dev/null; then
                ok=1
                break
              fi
              echo "Tentativa $i/5…"
              sleep 2
            done

            if [ "$ok" -ne 1 ]; then
              echo "Health-check falhou; iniciando rollback…"
              if [ -n "${PREV_RELEASE}" ] && [ -d "${PREV_RELEASE}" ]; then
                ln -sfn "${PREV_RELEASE}" "${CURRENT}"
                cd "${CURRENT}"
                if pm2 describe "${APP_NAME}" >/dev/null 2>&1; then
                  pm2 reload "${APP_NAME}" --update-env || pm2 restart "${APP_NAME}" --update-env
                fi
              fi
              pm2 logs "${APP_NAME}" --lines 80 || true
              exit 1
            fi

            # Housekeeping: mantém apenas KEEP_RELEASES (padrão 3)
            KEEP_RELEASES="${{ env.KEEP_RELEASES }}"
            keep="${KEEP_RELEASES:-3}"
            cd "${RELEASES}"
            count=$(( keep + 1 ))     # apaga da (keep+1)-ésima em diante
            ls -1dt */ | tail -n +$count | xargs -r rm -rf

            # Remove o bundle após sucesso
            rm -f "${UPLOADS}/deploy-${RELEASE_ID}.tar.gz"

            echo "Deploy OK: ${APP_NAME} -> ${CURRENT}"
