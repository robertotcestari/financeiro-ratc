name: Deploy financeiro-ratc

on:
  push:
    branches: [main]
    paths-ignore:
      - 'README.md'
      - 'docs/**'

permissions:
  contents: read

concurrency:
  group: deploy-financeiro-ratc-${{ github.ref }}
  cancel-in-progress: true

jobs:
  deploy:
    name: Build & Deploy (production)
    runs-on: ubuntu-latest
    timeout-minutes: 10

    env:
      # Quantidade de releases a manter
      KEEP_RELEASES: '3'

      # Configurações do app/infra
      APP_NAME: financeiro-ratc
      APP_DIR: /opt/financeiro-ratc
      DOMAIN: financeiro.ratc.com.br

      # Next/Prisma
      NEXT_TELEMETRY_DISABLED: '1'
      PRISMA_CLI_QUERY_ENGINE_TYPE: 'library'
      CI: 'true'

    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          persist-credentials: false

      - name: Compute release id
        run: |
          SHORT_SHA="${GITHUB_SHA::7}"
          TS="$(date +%Y%m%d%H%M%S)"
          echo "RELEASE_ID=${SHORT_SHA}-${TS}" >> "$GITHUB_ENV"

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '22'
          cache: 'npm'

      - name: Cache node_modules
        id: cache-node-modules
        uses: actions/cache@v4
        with:
          path: node_modules
          key: node-modules-${{ runner.os }}-${{ hashFiles('package-lock.json') }}
          restore-keys: |
            node-modules-${{ runner.os }}-

      - name: Cache Next.js build
        id: cache-nextjs-build
        uses: actions/cache@v4
        with:
          path: .next
          key: nextjs-build-${{ runner.os }}-${{ hashFiles('package-lock.json') }}-${{ hashFiles('**/*.js', '**/*.jsx', '**/*.ts', '**/*.tsx', 'prisma/schema.prisma') }}
          restore-keys: |
            nextjs-build-${{ runner.os }}-${{ hashFiles('package-lock.json') }}-
            nextjs-build-${{ runner.os }}-

      - name: Cache Prisma
        uses: actions/cache@v4
        with:
          path: ~/.cache/prisma
          key: prisma-${{ runner.os }}-${{ hashFiles('prisma/schema.prisma') }}
          restore-keys: |
            prisma-${{ runner.os }}-

      - name: Install dependencies
        if: steps.cache-node-modules.outputs.cache-hit != 'true'
        run: npm ci --prefer-offline --no-audit --fund=false

      - name: Write build-time .env (masked)
        run: |
          umask 077
          printf "%s" "${{ secrets.ENV }}" > .env
          echo "Build-time .env created"

      - name: Prisma generate (CI)
        if: steps.cache-nextjs-build.outputs.cache-hit != 'true'
        run: npx prisma generate

      - name: Build (Next.js)
        if: steps.cache-nextjs-build.outputs.cache-hit != 'true'
        env:
          NODE_OPTIONS: '--max-old-space-size=4096'
          SKIP_BUILD_CHECKS: 'true'
          # Dummy DATABASE_URL para os tipos do Prisma no build
          DATABASE_URL: 'mysql://user:pass@localhost:3306/db'
        run: |
          npm run build

      - name: Create deployment bundle
        run: |
          DEPLOY_DIR="deploy-bundle"
          rm -rf "$DEPLOY_DIR"
          mkdir -p "$DEPLOY_DIR"

          # Sempre inclua package.json e lock (úteis para build regular)
          cp package.json package-lock.json "$DEPLOY_DIR/"

          # Build regular (Next.js start): copiamos .next e recursos necessários
          cp -r .next "$DEPLOY_DIR/"
          [ -d public ] && cp -r public "$DEPLOY_DIR/" || true
          cp -r prisma "$DEPLOY_DIR/"
          # Estes diretórios/arquivos não são estritamente necessários em runtime,
          # mas mantê-los não causa problemas e ajuda em eventuais scripts.
          for d in app src lib components hooks; do [ -d "$d" ] && cp -r "$d" "$DEPLOY_DIR/" || true; done
          for f in next.config.* tsconfig.json proxy.ts; do [ -f "$f" ] && cp "$f" "$DEPLOY_DIR/" || true; done

          tar -czf "deploy-${RELEASE_ID}.tar.gz" -C "$DEPLOY_DIR" .
          echo "Bundle criado: deploy-${RELEASE_ID}.tar.gz"

      - name: Cleanup local .env
        if: always()
        run: rm -f .env || true

      - name: Upload bundle (debug opcional)
        uses: actions/upload-artifact@v4
        with:
          name: deploy-${{ env.RELEASE_ID }}
          path: deploy-${{ env.RELEASE_ID }}.tar.gz
          retention-days: 3

      - name: Ensure server base dirs
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ secrets.VPS_HOST }}
          username: ${{ secrets.VPS_USER }}
          key: ${{ secrets.VPS_SSH_KEY }}
          port: ${{ secrets.VPS_PORT || 22 }}
          script_stop: true
          script: |
            APP_DIR="${{ env.APP_DIR }}"
            mkdir -p "${APP_DIR}/releases" "${APP_DIR}/shared" "${APP_DIR}/uploads"
            [ -f "${APP_DIR}/shared/.env" ] || touch "${APP_DIR}/shared/.env"

      - name: Push bundle to server (rsync)
        uses: burnett01/rsync-deployments@7.0.1
        with:
          switches: -avz
          path: deploy-${{ env.RELEASE_ID }}.tar.gz
          remote_path: ${{ env.APP_DIR }}/uploads/
          remote_host: ${{ secrets.VPS_HOST }}
          remote_user: ${{ secrets.VPS_USER }}
          remote_key: ${{ secrets.VPS_SSH_KEY }}
          remote_port: ${{ secrets.VPS_PORT || 22 }}

      - name: Extract release bundle
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ secrets.VPS_HOST }}
          username: ${{ secrets.VPS_USER }}
          key: ${{ secrets.VPS_SSH_KEY }}
          port: ${{ secrets.VPS_PORT || 22 }}
          script_stop: true
          script: |
            APP_NAME="${{ env.APP_NAME }}"
            APP_DIR="${{ env.APP_DIR }}"
            RELEASE_ID="${{ env.RELEASE_ID }}"
            RELEASES="${APP_DIR}/releases"
            UPLOADS="${APP_DIR}/uploads"
            SHARED="${APP_DIR}/shared"
            CURRENT="${APP_DIR}/current"
            NEW_RELEASE="${RELEASES}/${RELEASE_ID}"

            # Extrai novo release
            echo "[ETAPA 1] Extraindo bundle..."
            mkdir -p "${NEW_RELEASE}"
            tar -xzf "${UPLOADS}/deploy-${RELEASE_ID}.tar.gz" -C "${NEW_RELEASE}"
            echo "✓ Bundle extraído com sucesso"

            # Faz o link com .env compartilhado
            echo "[ETAPA 2] Linkando arquivo .env..."
            ln -sfn "${SHARED}/.env" "${NEW_RELEASE}/.env"
            if [ -f "${NEW_RELEASE}/.env" ]; then
              echo "✓ Arquivo .env linkado"
            else
              echo "✗ ERRO: Arquivo .env não encontrado!"
              exit 1
            fi

            # Guarda release anterior (para rollback)
            PREV_RELEASE="$(readlink -f "${CURRENT}" 2>/dev/null || true)"
            echo "Release anterior: ${PREV_RELEASE:-'nenhum'}"

      - name: Install dependencies
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ secrets.VPS_HOST }}
          username: ${{ secrets.VPS_USER }}
          key: ${{ secrets.VPS_SSH_KEY }}
          port: ${{ secrets.VPS_PORT || 22 }}
          script_stop: true
          script: |
            APP_DIR="${{ env.APP_DIR }}"
            RELEASE_ID="${{ env.RELEASE_ID }}"
            RELEASES="${APP_DIR}/releases"
            SHARED="${APP_DIR}/shared"
            NEW_RELEASE="${RELEASES}/${RELEASE_ID}"

            cd "${NEW_RELEASE}"

            echo "[ETAPA 3] Instalando dependências de runtime (build regular)…"
            # Debug: lista arquivos no diretório
            echo "Conteúdo do diretório:"
            ls -la | head -20

            if [ ! -f "package.json" ] || [ ! -f "package-lock.json" ]; then
              echo "✗ ERRO: package.json ou package-lock.json não encontrado!"
              exit 1
            fi

            export NPM_CONFIG_CACHE="${SHARED}/.npm"
            echo "Executando: npm ci --omit=dev --no-audit --fund=false"
            npm ci --omit=dev --no-audit --fund=false 2>&1 || {
              echo "✗ ERRO ao instalar dependências (npm ci)!"
              exit 1
            }
            echo "✓ Dependências instaladas"

      - name: Run Prisma migrations
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ secrets.VPS_HOST }}
          username: ${{ secrets.VPS_USER }}
          key: ${{ secrets.VPS_SSH_KEY }}
          port: ${{ secrets.VPS_PORT || 22 }}
          script_stop: true
          script: |
            APP_DIR="${{ env.APP_DIR }}"
            RELEASE_ID="${{ env.RELEASE_ID }}"
            RELEASES="${APP_DIR}/releases"
            NEW_RELEASE="${RELEASES}/${RELEASE_ID}"

            cd "${NEW_RELEASE}"

            # Verifica conexão com banco de dados
            echo "[ETAPA 4] Configurando Prisma..."
            export NODE_ENV=production
            export NEXT_TELEMETRY_DISABLED=1
            export PRISMA_CLI_QUERY_ENGINE_TYPE=library

            # Carrega .env para obter DATABASE_URL
            if [ -f ".env" ]; then
              export $(grep -v '^#' .env | xargs)
            fi

            echo "Executando prisma migrate deploy…"
            npx --yes prisma migrate deploy 2>&1 || {
              echo "✗ ERRO nas migrations!"
              exit 1
            }
            echo "✓ Migrations executadas"

            echo "Gerando prisma client…"
            npx --yes prisma generate 2>&1 || {
              echo "✗ ERRO ao gerar Prisma client!"
              exit 1
            }
            echo "✓ Prisma client gerado"

      - name: Switch to new release and restart PM2
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ secrets.VPS_HOST }}
          username: ${{ secrets.VPS_USER }}
          key: ${{ secrets.VPS_SSH_KEY }}
          port: ${{ secrets.VPS_PORT || 22 }}
          script_stop: true
          script: |
            APP_NAME="${{ env.APP_NAME }}"
            APP_DIR="${{ env.APP_DIR }}"
            RELEASE_ID="${{ env.RELEASE_ID }}"
            RELEASES="${APP_DIR}/releases"
            CURRENT="${APP_DIR}/current"
            NEW_RELEASE="${RELEASES}/${RELEASE_ID}"

            # Guarda release anterior
            PREV_RELEASE="$(readlink -f "${CURRENT}" 2>/dev/null || true)"

            # Aponta 'current' para o novo release
            echo "[ETAPA 5] Atualizando symlink..."
            ln -sfn "${NEW_RELEASE}" "${CURRENT}"
            echo "✓ Symlink atualizado para: ${NEW_RELEASE}"

            # Start/reload com PM2 a partir de 'current'
            cd "${CURRENT}"

            # Carrega variáveis do .env para o ambiente do shell (PM2/Next em runtime)
            echo "[ETAPA 6] Carregando variáveis de ambiente..."
            if [ -f ".env" ]; then
              set +u
              set -a
              . ./.env
              set +a
              set -u
              echo "✓ Variáveis de ambiente carregadas"
            else
              echo "⚠ Arquivo .env não encontrado"
            fi

            PORT="${PORT:-3000}"
            echo "Porta configurada: ${PORT}"

            echo "[ETAPA 7] Reiniciando aplicação com PM2..."
            # Usamos o binário do Next diretamente para evitar wrappers do npm/shell
            START_NODE="node"
            START_SCRIPT="node_modules/next/dist/bin/next"
            START_ARGS=(start -p "$PORT")

            # Mostra versões para debug
            echo "node: $(command -v node) | $(node -v 2>/dev/null || echo 'node not found')"
            echo "npm:  $(command -v npm)  | $(npm -v 2>/dev/null || echo 'npm not found')"
            echo "pm2:  $(command -v pm2)  | $(pm2 -v 2>/dev/null || echo 'pm2 not found')"
            ls -la node_modules/.bin || true

            # Se já existir, exclui e inicia novamente com comando explícito
            if pm2 describe "${APP_NAME}" >/dev/null 2>&1; then
              echo "Aplicação já existe no PM2. Reiniciando com comando explícito..."
              pm2 delete "${APP_NAME}" || true
            fi

            echo "Iniciando: $START_NODE $START_SCRIPT ${START_ARGS[*]}"
            pm2 start "$START_NODE" --name "${APP_NAME}" --time -- "$START_SCRIPT" "${START_ARGS[@]}" || {
              echo "✗ Falha ao iniciar via PM2. Últimos logs:";
              pm2 logs "${APP_NAME}" --nostream --lines 50 || true;
              exit 1;
            }

            pm2 save || true
            echo "✓ PM2 configurado"

            # Mostra status do PM2
            echo "\n[STATUS PM2]"
            pm2 status "${APP_NAME}" || true

      - name: Health check
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ secrets.VPS_HOST }}
          username: ${{ secrets.VPS_USER }}
          key: ${{ secrets.VPS_SSH_KEY }}
          port: ${{ secrets.VPS_PORT || 22 }}
          script_stop: true
          script: |
            # Garante PATH completo
            export PATH="/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:$PATH"

            APP_NAME="${{ env.APP_NAME }}"
            APP_DIR="${{ env.APP_DIR }}"
            CURRENT="${APP_DIR}/current"
            RELEASES="${APP_DIR}/releases"

            cd "${CURRENT}"

            # Carrega porta do .env
            if [ -f ".env" ]; then
              export $(grep -v '^#' .env | grep -E '^PORT=' | xargs)
            fi
            PORT="${PORT:-3000}"

            # Função para fazer HTTP request (curl ou wget)
            http_check() {
              if command -v curl >/dev/null 2>&1; then
                curl -fsS --max-time 5 "$1" >/dev/null 2>&1
              elif command -v wget >/dev/null 2>&1; then
                wget -q --timeout=5 -O /dev/null "$1" 2>/dev/null
              else
                # Fallback: usa /dev/tcp do bash
                exec 3<>/dev/tcp/127.0.0.1/${PORT} 2>/dev/null && exec 3>&-
              fi
            }

            # Health-check com mais detalhes
            echo "[ETAPA 8] Health check em http://127.0.0.1:${PORT}/"
            ok=0
            for i in 1 2 3 4 5 6 7 8 9 10; do
              echo "Tentativa $i/10..."
              if http_check "http://127.0.0.1:${PORT}/"; then
                echo "✓ Aplicação respondendo!"
                ok=1
                break
              else
                echo "Aguardando aplicação iniciar..."
                # Mostra logs do PM2 para debug
                if [ "$i" -eq 5 ]; then
                  echo ""
                  echo "[LOGS PM2 - Últimas 20 linhas]"
                  pm2 logs "${APP_NAME}" --nostream --lines 20 || true
                  echo ""
                fi
                sleep 3
              fi
            done

            if [ "$ok" -ne 1 ]; then
              echo ""
              echo "✗ Health-check FALHOU após 10 tentativas!"
              echo ""
              echo "[LOGS PM2 COMPLETOS]"
              pm2 logs "${APP_NAME}" --nostream --lines 100 || true

              # Tenta fazer rollback
              PREV_RELEASE="$(readlink -f "${CURRENT}" 2>/dev/null || true)"
              if [ -n "${PREV_RELEASE}" ] && [ -d "${PREV_RELEASE}" ] && [ "${PREV_RELEASE}" != "${CURRENT}" ]; then
                echo ""
                echo "[ROLLBACK] Voltando para release anterior: ${PREV_RELEASE}"
                ln -sfn "${PREV_RELEASE}" "${CURRENT}"
                cd "${CURRENT}"
                pm2 reload "${APP_NAME}" --update-env || pm2 restart "${APP_NAME}" --update-env
              fi
              exit 1
            fi

            echo ""
            echo "✓ Deploy concluído com sucesso!"

      - name: Cleanup old releases
        uses: appleboy/ssh-action@v1.0.3
        if: success()
        with:
          host: ${{ secrets.VPS_HOST }}
          username: ${{ secrets.VPS_USER }}
          key: ${{ secrets.VPS_SSH_KEY }}
          port: ${{ secrets.VPS_PORT || 22 }}
          script_stop: false
          script: |
            APP_DIR="${{ env.APP_DIR }}"
            RELEASE_ID="${{ env.RELEASE_ID }}"
            RELEASES="${APP_DIR}/releases"
            UPLOADS="${APP_DIR}/uploads"
            KEEP_RELEASES="${{ env.KEEP_RELEASES }}"

            # Housekeeping: mantém apenas KEEP_RELEASES (padrão 3)
            echo "[LIMPEZA] Mantendo apenas ${KEEP_RELEASES} releases..."
            keep="${KEEP_RELEASES:-3}"
            cd "${RELEASES}"
            count=$(( keep + 1 ))
            ls -1dt */ | tail -n +$count | xargs -r rm -rf || true

            # Remove o bundle após sucesso
            rm -f "${UPLOADS}/deploy-${RELEASE_ID}.tar.gz"
            echo "✓ Limpeza concluída"
