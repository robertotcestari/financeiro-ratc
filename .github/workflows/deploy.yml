name: Deploy financeiro-ratc

on:
  push:
    branches: [main]
    paths-ignore:
      - 'README.md'
      - 'docs/**'
  workflow_dispatch:

permissions:
  contents: read

concurrency:
  group: deploy-financeiro-ratc-${{ github.ref }}
  cancel-in-progress: true

jobs:
  deploy:
    name: Build & Deploy (production)
    runs-on: ubuntu-latest
    timeout-minutes: 10

    env:
      # Quantidade de releases a manter
      KEEP_RELEASES: '3'

      # Configurações do app/infra
      APP_NAME: financeiro-ratc
      APP_DIR: /opt/financeiro-ratc
      DOMAIN: financeiro.ratc.com.br

      # Node/Next/Prisma
      NODE_VERSION: '22'
      NEXT_TELEMETRY_DISABLED: '1'
      PRISMA_CLI_QUERY_ENGINE_TYPE: 'library'
      CI: 'true'

    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          persist-credentials: false

      - name: Compute release id
        run: |
          SHORT_SHA="${GITHUB_SHA::7}"
          TS="$(date +%Y%m%d%H%M%S)"
          echo "RELEASE_ID=${SHORT_SHA}-${TS}" >> "$GITHUB_ENV"

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'
          cache-dependency-path: 'package-lock.json'

      - name: Cache dependencies
        uses: actions/cache@v4
        with:
          path: ~/.npm
          key: npm-${{ runner.os }}-node${{ env.NODE_VERSION }}-${{ hashFiles('package-lock.json') }}
          restore-keys: |
            npm-${{ runner.os }}-node${{ env.NODE_VERSION }}-
            npm-${{ runner.os }}-
      
      - name: Cache Next.js build
        uses: actions/cache@v4
        with:
          path: |
            .next/cache
            ${{ github.workspace }}/.next/cache
          key: nextjs-${{ runner.os }}-${{ hashFiles('package-lock.json') }}-${{ hashFiles('**/*.js', '**/*.jsx', '**/*.ts', '**/*.tsx', '**/*.json') }}
          restore-keys: |
            nextjs-${{ runner.os }}-${{ hashFiles('package-lock.json') }}-
            nextjs-${{ runner.os }}-
      
      - name: Cache Prisma
        uses: actions/cache@v4
        with:
          path: ~/.cache/prisma
          key: prisma-${{ runner.os }}-${{ hashFiles('prisma/schema.prisma') }}
          restore-keys: |
            prisma-${{ runner.os }}-

      - name: Install dependencies
        run: npm ci --prefer-offline --no-audit --fund=false --cache ~/.npm

      - name: Write build-time .env (masked)
        run: |
          umask 077
          printf "%s" "${{ secrets.ENV }}" > .env
          echo "Build-time .env created"

      - name: Prisma generate (CI)
        run: npx prisma generate

      - name: Build (Next.js standalone if enabled)
        env:
          NODE_OPTIONS: '--max-old-space-size=4096'
          SKIP_BUILD_CHECKS: 'true'
          # Dummy DATABASE_URL para os tipos do Prisma no build
          DATABASE_URL: 'mysql://user:pass@localhost:3306/db'
        run: |
          npm run build
          if [ -d ".next/standalone" ]; then
            echo "Standalone build ✅"
          else
            echo "Standalone build não encontrado; será usado build regular ⚠"
          fi

      - name: Create deployment bundle
        run: |
          DEPLOY_DIR="deploy-bundle"
          rm -rf "$DEPLOY_DIR"
          mkdir -p "$DEPLOY_DIR"

          # Sempre inclua package.json e lock (úteis para build regular)
          cp package.json package-lock.json "$DEPLOY_DIR/"

          if [ -d ".next/standalone" ]; then
            cp -r .next/standalone/* "$DEPLOY_DIR/"
            mkdir -p "$DEPLOY_DIR/.next"
            cp -r .next/static "$DEPLOY_DIR/.next/static"
            [ -d public ] && cp -r public "$DEPLOY_DIR/" || true
            cp -r prisma "$DEPLOY_DIR/"
          else
            cp -r .next "$DEPLOY_DIR/"
            [ -d public ] && cp -r public "$DEPLOY_DIR/" || true
            cp -r prisma "$DEPLOY_DIR/"
            for d in app src lib components hooks; do [ -d "$d" ] && cp -r "$d" "$DEPLOY_DIR/" || true; done
            for f in next.config.* tsconfig.json middleware.ts; do [ -f "$f" ] && cp "$f" "$DEPLOY_DIR/" || true; done
          fi

          tar -czf "deploy-${RELEASE_ID}.tar.gz" -C "$DEPLOY_DIR" .
          echo "Bundle criado: deploy-${RELEASE_ID}.tar.gz"

      - name: Cleanup local .env
        if: always()
        run: rm -f .env || true

      - name: Upload bundle (debug opcional)
        uses: actions/upload-artifact@v4
        with:
          name: deploy-${{ env.RELEASE_ID }}
          path: deploy-${{ env.RELEASE_ID }}.tar.gz
          retention-days: 3

      - name: Ensure server base dirs
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ secrets.VPS_HOST }}
          username: ${{ secrets.VPS_USER }}
          key: ${{ secrets.VPS_SSH_KEY }}
          port: ${{ secrets.VPS_PORT || 22 }}
          script_stop: true
          script: |
            APP_DIR="${{ env.APP_DIR }}"
            mkdir -p "${APP_DIR}/releases" "${APP_DIR}/shared" "${APP_DIR}/uploads"
            [ -f "${APP_DIR}/shared/.env" ] || touch "${APP_DIR}/shared/.env"

      - name: Push bundle to server (rsync)
        uses: burnett01/rsync-deployments@7.0.1
        with:
          switches: -avz
          path: deploy-${{ env.RELEASE_ID }}.tar.gz
          remote_path: ${{ env.APP_DIR }}/uploads/
          remote_host: ${{ secrets.VPS_HOST }}
          remote_user: ${{ secrets.VPS_USER }}
          remote_key: ${{ secrets.VPS_SSH_KEY }}
          remote_port: ${{ secrets.VPS_PORT || 22 }}

      - name: Extract release bundle
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ secrets.VPS_HOST }}
          username: ${{ secrets.VPS_USER }}
          key: ${{ secrets.VPS_SSH_KEY }}
          port: ${{ secrets.VPS_PORT || 22 }}
          script_stop: true
          script: |
            APP_NAME="${{ env.APP_NAME }}"
            APP_DIR="${{ env.APP_DIR }}"
            RELEASE_ID="${{ env.RELEASE_ID }}"
            RELEASES="${APP_DIR}/releases"
            UPLOADS="${APP_DIR}/uploads"
            SHARED="${APP_DIR}/shared"
            CURRENT="${APP_DIR}/current"
            NEW_RELEASE="${RELEASES}/${RELEASE_ID}"

            # Extrai novo release
            echo "[ETAPA 1] Extraindo bundle..."
            mkdir -p "${NEW_RELEASE}"
            tar -xzf "${UPLOADS}/deploy-${RELEASE_ID}.tar.gz" -C "${NEW_RELEASE}"
            echo "✓ Bundle extraído com sucesso"

            # Linka .env compartilhado
            echo "[ETAPA 2] Linkando arquivo .env..."
            ln -sfn "${SHARED}/.env" "${NEW_RELEASE}/.env"
            if [ -f "${NEW_RELEASE}/.env" ]; then
              echo "✓ Arquivo .env linkado"
            else
              echo "✗ ERRO: Arquivo .env não encontrado!"
              exit 1
            fi

            # Guarda release anterior (para rollback)
            PREV_RELEASE="$(readlink -f "${CURRENT}" 2>/dev/null || true)"
            echo "Release anterior: ${PREV_RELEASE:-'nenhum'}"

      - name: Install dependencies (if needed)
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ secrets.VPS_HOST }}
          username: ${{ secrets.VPS_USER }}
          key: ${{ secrets.VPS_SSH_KEY }}
          port: ${{ secrets.VPS_PORT || 22 }}
          script_stop: true
          script: |
            APP_DIR="${{ env.APP_DIR }}"
            RELEASE_ID="${{ env.RELEASE_ID }}"
            RELEASES="${APP_DIR}/releases"
            SHARED="${APP_DIR}/shared"
            NEW_RELEASE="${RELEASES}/${RELEASE_ID}"

            cd "${NEW_RELEASE}"

            # Instala dependências apenas para build regular
            echo "[ETAPA 3] Verificando tipo de build..."

            # Debug: lista arquivos no diretório
            echo "Conteúdo do diretório:"
            ls -la | head -20

            if [ ! -f "server.js" ]; then
              echo "Build regular detectado — instalando dependências de runtime…"
              
              # Verifica se package.json existe
              if [ ! -f "package.json" ]; then
                echo "✗ ERRO: package.json não encontrado!"
                exit 1
              fi
              
              # Verifica se package-lock.json existe  
              if [ ! -f "package-lock.json" ]; then
                echo "✗ ERRO: package-lock.json não encontrado!"
                exit 1
              fi
              
              export NPM_CONFIG_CACHE="${SHARED}/.npm"
              echo "Executando: npm install --omit=dev --no-audit --fund=false"
              npm install --omit=dev --no-audit --fund=false 2>&1
              EXIT_CODE=$?
              if [ $EXIT_CODE -ne 0 ]; then
                echo "✗ ERRO ao instalar dependências! Código de saída: $EXIT_CODE"
                exit 1
              fi
              echo "✓ Dependências instaladas"
            else
              echo "Standalone detectado — pulando npm install."
            fi

      - name: Run Prisma migrations
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ secrets.VPS_HOST }}
          username: ${{ secrets.VPS_USER }}
          key: ${{ secrets.VPS_SSH_KEY }}
          port: ${{ secrets.VPS_PORT || 22 }}
          script_stop: true
          script: |
            APP_DIR="${{ env.APP_DIR }}"
            RELEASE_ID="${{ env.RELEASE_ID }}"
            RELEASES="${APP_DIR}/releases"
            NEW_RELEASE="${RELEASES}/${RELEASE_ID}"

            cd "${NEW_RELEASE}"

            # Verifica conexão com banco de dados
            echo "[ETAPA 4] Configurando Prisma..."
            export NODE_ENV=production
            export NEXT_TELEMETRY_DISABLED=1
            export PRISMA_CLI_QUERY_ENGINE_TYPE=library

            # Carrega .env para obter DATABASE_URL
            if [ -f ".env" ]; then
              export $(grep -v '^#' .env | xargs)
            fi

            echo "Executando prisma migrate deploy…"
            npx --yes prisma migrate deploy 2>&1 || {
              echo "✗ ERRO nas migrations!"
              exit 1
            }
            echo "✓ Migrations executadas"

            echo "Gerando prisma client…"
            npx --yes prisma generate 2>&1 || {
              echo "✗ ERRO ao gerar Prisma client!"
              exit 1
            }
            echo "✓ Prisma client gerado"

      - name: Switch to new release and restart PM2
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ secrets.VPS_HOST }}
          username: ${{ secrets.VPS_USER }}
          key: ${{ secrets.VPS_SSH_KEY }}
          port: ${{ secrets.VPS_PORT || 22 }}
          script_stop: true
          script: |
            APP_NAME="${{ env.APP_NAME }}"
            APP_DIR="${{ env.APP_DIR }}"
            RELEASE_ID="${{ env.RELEASE_ID }}"
            RELEASES="${APP_DIR}/releases"
            CURRENT="${APP_DIR}/current"
            NEW_RELEASE="${RELEASES}/${RELEASE_ID}"

            # Guarda release anterior
            PREV_RELEASE="$(readlink -f "${CURRENT}" 2>/dev/null || true)"

            # Aponta 'current' para o novo release
            echo "[ETAPA 5] Atualizando symlink..."
            ln -sfn "${NEW_RELEASE}" "${CURRENT}"
            echo "✓ Symlink atualizado para: ${NEW_RELEASE}"

            # Start/reload com PM2 a partir de 'current'
            cd "${CURRENT}"

            # Carrega variáveis do .env para o ambiente do shell (PM2/Next em runtime)
            echo "[ETAPA 6] Carregando variáveis de ambiente..."
            if [ -f ".env" ]; then
              set +u
              set -a
              . ./.env
              set +a
              set -u
              echo "✓ Variáveis de ambiente carregadas"
            else
              echo "⚠ Arquivo .env não encontrado"
            fi

            PORT="${PORT:-3000}"
            echo "Porta configurada: ${PORT}"

            echo "[ETAPA 7] Reiniciando aplicação com PM2..."
            if pm2 describe "${APP_NAME}" >/dev/null 2>&1; then
              echo "Aplicação já existe no PM2. Fazendo reload..."
              pm2 reload "${APP_NAME}" --update-env || pm2 restart "${APP_NAME}" --update-env
            else
              echo "Primeira vez rodando. Iniciando aplicação..."
              if [ -f "server.js" ]; then
                echo "Iniciando com server.js (standalone)..."
                pm2 start "node server.js" --name "${APP_NAME}" --time
              elif [ -f "package.json" ] && grep -q '"start"' package.json; then
                echo "Iniciando com npm start..."
                pm2 start "npm start" --name "${APP_NAME}" --time
              else
                echo "Iniciando com next start direto..."
                pm2 start "node node_modules/.bin/next start" --name "${APP_NAME}" --time
              fi
            fi

            pm2 save || true
            echo "✓ PM2 configurado"

            # Mostra status do PM2
            echo "\n[STATUS PM2]"
            pm2 status "${APP_NAME}" || true

      - name: Health check
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ secrets.VPS_HOST }}
          username: ${{ secrets.VPS_USER }}
          key: ${{ secrets.VPS_SSH_KEY }}
          port: ${{ secrets.VPS_PORT || 22 }}
          script_stop: true
          script: |
            APP_NAME="${{ env.APP_NAME }}"
            APP_DIR="${{ env.APP_DIR }}"
            CURRENT="${APP_DIR}/current"
            RELEASES="${APP_DIR}/releases"

            cd "${CURRENT}"

            # Carrega porta do .env
            if [ -f ".env" ]; then
              export $(grep -v '^#' .env | grep -E '^PORT=' | xargs)
            fi
            PORT="${PORT:-3000}"

            # Health-check com mais detalhes
            echo "[ETAPA 8] Health check em http://127.0.0.1:${PORT}/"
            ok=0
            for i in 1 2 3 4 5 6 7 8 9 10; do
              echo "Tentativa $i/10..."
              if curl -fsS --max-time 5 "http://127.0.0.1:${PORT}/" >/dev/null 2>&1; then
                echo "✓ Aplicação respondendo!"
                ok=1
                break
              else
                echo "Aguardando aplicação iniciar..."
                # Mostra logs do PM2 para debug
                if [ "$i" -eq 5 ]; then
                  echo "\n[LOGS PM2 - Últimas 20 linhas]"
                  pm2 logs "${APP_NAME}" --nostream --lines 20 || true
                  echo "\n"
                fi
                sleep 3
              fi
            done

            if [ "$ok" -ne 1 ]; then
              echo "\n✗ Health-check FALHOU após 10 tentativas!"
              echo "\n[LOGS PM2 COMPLETOS]"
              pm2 logs "${APP_NAME}" --nostream --lines 100 || true
              
              # Tenta fazer rollback
              PREV_RELEASE="$(readlink -f "${CURRENT}" 2>/dev/null || true)"
              if [ -n "${PREV_RELEASE}" ] && [ -d "${PREV_RELEASE}" ] && [ "${PREV_RELEASE}" != "${CURRENT}" ]; then
                echo "\n[ROLLBACK] Voltando para release anterior: ${PREV_RELEASE}"
                ln -sfn "${PREV_RELEASE}" "${CURRENT}"
                cd "${CURRENT}"
                pm2 reload "${APP_NAME}" --update-env || pm2 restart "${APP_NAME}" --update-env
              fi
              exit 1
            fi

            echo "\n✓ Deploy concluído com sucesso!"

      - name: Cleanup old releases
        uses: appleboy/ssh-action@v1.0.3
        if: success()
        with:
          host: ${{ secrets.VPS_HOST }}
          username: ${{ secrets.VPS_USER }}
          key: ${{ secrets.VPS_SSH_KEY }}
          port: ${{ secrets.VPS_PORT || 22 }}
          script_stop: false
          script: |
            APP_DIR="${{ env.APP_DIR }}"
            RELEASE_ID="${{ env.RELEASE_ID }}"
            RELEASES="${APP_DIR}/releases"
            UPLOADS="${APP_DIR}/uploads"
            KEEP_RELEASES="${{ env.KEEP_RELEASES }}"

            # Housekeeping: mantém apenas KEEP_RELEASES (padrão 3)
            echo "[LIMPEZA] Mantendo apenas ${KEEP_RELEASES} releases..."
            keep="${KEEP_RELEASES:-3}"
            cd "${RELEASES}"
            count=$(( keep + 1 ))
            ls -1dt */ | tail -n +$count | xargs -r rm -rf || true

            # Remove o bundle após sucesso
            rm -f "${UPLOADS}/deploy-${RELEASE_ID}.tar.gz"
            echo "✓ Limpeza concluída"
