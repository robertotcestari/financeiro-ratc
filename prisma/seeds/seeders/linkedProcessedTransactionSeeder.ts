import { PrismaClient } from '@/app/generated/prisma'
import * as fs from 'fs'
import * as path from 'path'
import { parse } from 'csv-parse/sync'
import { nanoid } from 'nanoid'

interface LinkedProcessedRow {
  transactionId: string
  year: string
  month: string
  propertyRef: string
  category: string
  account: string
  details: string
  date: string
  description: string
  value: string
  categoryId: string
}

function parseBRLNumber(text: any): number | null {
  if (text === undefined || text === null) return null
  const s = String(text).replace(/\./g, '').replace(',', '.')
  const n = parseFloat(s)
  return Number.isNaN(n) ? null : n
}

function parseBRDate(text: any): Date | null {
  if (!text) return null
  const [d, m, y] = String(text).split('/')
  if (!y) return null
  return new Date(Date.UTC(parseInt(y, 10), parseInt(m, 10) - 1, parseInt(d, 10)))
}

export async function seedLinkedProcessedTransactions(prisma: PrismaClient) {
  console.log('üîó Creating linked processed transactions...')
  
  const csvPath = path.join(__dirname, '../data', 'Contratos de Loca√ß√£o - Contas Unificadas - New Categories - With IDs - Fixed.csv')
  const csvContent = fs.readFileSync(csvPath, 'utf-8')
  const rows = parse(csvContent, { 
    columns: ['year', 'month', 'propertyRef', 'category', 'account', 'details', 'date', 'description', 'value', 'categoryId', 'transactionId'],
    skip_empty_lines: true,
    from_line: 2 // Skip header
  }) as LinkedProcessedRow[]

  // Get lookup maps
  const bankAccounts = await prisma.bankAccount.findMany()
  const accountMap = new Map(bankAccounts.map(acc => [acc.name, acc.id]))

  const categories = await prisma.category.findMany()  
  const categoryMap = new Map(categories.map(cat => [cat.id, cat]))

  const properties = await prisma.property.findMany()
  const propertyMap = new Map(properties.map(prop => [prop.code, prop.id]))

  let created = 0
  let skipped = 0
  let transactionsCreated = 0

  for (const row of rows) {
    const { transactionId, year, month, propertyRef, category, account, details, date, description, value, categoryId } = row
    
    if (!account || !date || !value) {
      console.log(`‚ö†Ô∏è  Skipping invalid row: ${JSON.stringify(row)}`)
      skipped++
      continue
    }

    const parsedValue = parseBRLNumber(value)
    const parsedDate = parseBRDate(date)
    const parsedYear = parseInt(year)
    const parsedMonth = parseInt(month)
    
    if (!parsedValue || !parsedDate || !parsedYear || !parsedMonth) {
      console.log(`‚ö†Ô∏è  Skipping row with invalid data: ${value}, ${date}, ${year}, ${month}`)
      skipped++
      continue
    }

    const accountId = accountMap.get(account)
    if (!accountId) {
      console.log(`‚ö†Ô∏è  Unknown account: ${account}`)
      skipped++
      continue
    }

    const categoryRecord = categoryMap.get(categoryId)
    if (!categoryRecord) {
      console.log(`‚ö†Ô∏è  Unknown category: ${categoryId}`)
      skipped++
      continue
    }

    const propertyId = propertyRef && propertyRef !== '-' ? propertyMap.get(propertyRef) || null : null

    try {
      // Check if transaction already exists
      let existingTransaction = await prisma.transaction.findUnique({
        where: { id: transactionId }
      })

      // If transaction doesn't exist (unmatched entries), create it
      if (!existingTransaction) {
        existingTransaction = await prisma.transaction.create({
          data: {
            id: transactionId, // Use the nanoid generated by the linking script
            bankAccountId: accountId,
            date: parsedDate,
            description: description || category || 'Imported from CSV',
            amount: parsedValue,
            balance: null, // We don't have balance info for manual entries
            importBatchId: null // Manual entries don't belong to an import batch
          }
        })
        transactionsCreated++
        console.log(`‚ûï Created new transaction: ${transactionId}`)
      }

      // Check if ProcessedTransaction already exists for this transaction
      const existingProcessed = await prisma.processedTransaction.findUnique({
        where: { transactionId: existingTransaction.id }
      })

      if (!existingProcessed) {
        // Create processed transaction only if it doesn't exist
        await prisma.processedTransaction.create({
          data: {
            transaction: { connect: { id: existingTransaction.id } },
            year: parsedYear,
            month: parsedMonth,
            category: { connect: { id: categoryId } },
            ...(propertyId ? { property: { connect: { id: propertyId } } } : {}),
            details: details || null,
            isReviewed: true // Mark as reviewed since these come from manual categorization
          }
        })
      } else {
        // Update existing processed transaction with new categorization
        await prisma.processedTransaction.update({
          where: { transactionId: existingTransaction.id },
          data: {
            category: { connect: { id: categoryId } },
            ...(propertyId
              ? { property: { connect: { id: propertyId } } }
              : { property: { disconnect: true } }),
            details: details || null,
            isReviewed: true,
            updatedAt: new Date()
          }
        })
        console.log(`üîÑ Updated existing processed transaction: ${transactionId}`)
      }

      created++
    } catch (error) {
      console.log(`‚ùå Error processing row: ${JSON.stringify(row)}`)
      console.log(`   Error: ${error}`)
      skipped++
    }
  }

  console.log(`   ‚úÖ Created ${created} linked processed transactions`)
  console.log(`   ‚ûï Created ${transactionsCreated} new transactions for unmatched entries`)
  console.log(`   ‚ö†Ô∏è  Skipped ${skipped} rows`)
}
